#!/usr/bin/env python3
#
# Adapts images to a given resolution.
#
# Copyright (C) 2016 Arun Prakash Jana <engineerarun@gmail.com>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

import argparse
import sys
import os
import shutil
import PIL
from PIL import Image, ImageFile

HRES = 0
VRES = 0
scale = None
brute = False
overwrite = False
nolarge = False
optimize = False
dot = False
recursive = False
_VERSION_ = '0.1'

def getres(res):
    hxv = res.split('x')
    if len(hxv) != 2:
        return (0, 0)

    try:
        return(int(hxv[0]), int(hxv[1]))
    except:
        return (0, 0)

def traverse_dir(path):
    try:
        for entry in os.scandir(path):
            # Add check for hidden here
            if not dot and entry.name.startswith('.'):
                continue

            if entry.is_dir():
                if recursive:
                    if not os.access(entry.path, os.W_OK | os.X_OK):
                        print(entry.path + ': no permission')
                        continue
                    traverse_dir(entry.path)
            else:
                resize_image(entry.path)
    except OSError as e:
        print(e)

def resize_image(src):
    global HRES, VRES
    # TODO: add a check for image size comparison with convert
    name, ext = os.path.splitext(src)

    try:
        img = Image.open(src)
        srcformat = img.format
    except OSError as e:
        print(e)
        return

    hres = img.size[0]
    vres = img.size[1]
    ImageFile.MAXBLOCK = hres * vres

    print(src + ': %dx%d' % (hres, vres))

    if scale:
        if scale == 100:
            HRES = hres
            VRES = vres
        else:
            HRES = int(round(hres * scale/float(100)))
            VRES = int(round(vres * scale/float(100)))

    if HRES == hres and VRES == vres:
        print('same %dx%d\n' % (HRES, VRES))
    elif brute:
        img = img.resize((HRES, VRES), PIL.Image.ANTIALIAS)
        print('brute %dx%d\n' % (HRES, VRES))
    else:
        ratio_img = float(hres/vres)
        ratio_target = float(HRES/VRES)

        if ratio_img >= ratio_target:
            if nolarge and HRES > hres:
                return

            # re-sample as per target horizontal resolution
            hratio = HRES/float(hres)
            target_vres = vres * hratio
            if target_vres >= int(target_vres) + .5:
                target_vres = target_vres + 1
            target_vres = int(target_vres)

            img = img.resize((HRES, target_vres), PIL.Image.ANTIALIAS)
            print('calculated %dx%d\n' % (HRES, target_vres))
        else:
            if nolarge and VRES > vres:
                return

            # re-sample as per target vertical resolution
            vratio = VRES/float(vres)
            target_hres = hres * vratio
            if target_hres >= int(target_hres) + .5:
                target_hres = target_hres + 1
            target_hres = int(target_hres)

            img = img.resize((target_hres, VRES), PIL.Image.ANTIALIAS)
            print('calculated %dx%d\n' % (target_hres, VRES))

    try:
        if not optimize:
            img.save(name + '_RESIZED' + ext, srcformat)
        else:
            img.save(name + '_RESIZED' + ext, srcformat, optimize=True)

        if overwrite:
            shutil.move(name + '_RESIZED' + ext, src)
    except OSError as e:
        print(e)

class ExtendedArgumentParser(argparse.ArgumentParser):
    """Extend classic argument parser"""

    # Print additional help and info
    @staticmethod
    def print_extended_help(file=None):
        if not file:
            file = sys.stderr

        file.write('''
Version %s
Copyright (C) 2016 Arun Prakash Jana <engineerarun@gmail.com>
License: GPLv3
Webpage: https://github.com/jarun/buku
''' % _VERSION_)

    # Help
    def print_help(self, file=None):
        super(ExtendedArgumentParser, self).print_help(file)
        self.print_extended_help(file)

def parse_args(args=None, namespace=None):
    """Parse imgd arguments/options.
    Parameters
    ----------
    args : list, optional
        Arguments to parse. Default is ``sys.argv``.
    namespace : argparse.Namespace
        Namespace to write to. Default is a new namespace.
    Returns
    -------
    argparse.Namespace
        Namespace with parsed arguments / options.
    """
    argparser = ExtendedArgumentParser(description='Adapt images to a resolution.')
    addarg = argparser.add_argument
    addarg('-x', '--res', dest='res', nargs=1, metavar='resolution',
           help='output resolution in HxV format')
    addarg('-s', '--scale', dest='scale', type=int, metavar='percentage',
           help='scale image to percentage')
    addarg('-b', '--brute', dest='brute', action='store_true',
           help='force to output resolution')
    addarg('-w', '--overwrite', dest='overwrite', action='store_true',
           help='overwrite source images')
    addarg('-n', '--nolarge', dest='nolarge', action='store_true',
           help='do not enlarge smaller images')
    addarg('-p', '--optimize', dest='optimize', action='store_true',
           help='optimize the output images')
    addarg('-d', '--dot', dest='dot', action='store_true',
           help='include hidden files')
    addarg('-r', '--recursive', dest='recursive', action='store_true',
           help='process directories recursively')
    addarg('keywords', nargs='+', metavar='PATH',
           help='source file or directory')

    # Show help and exit if no arguments
    if len(sys.argv) < 2:
        argparser.print_help(sys.stderr)
        sys.exit(1)

    return argparser.parse_args(args, namespace)

def main():
    global HRES, VRES, scale, brute, overwrite, nolarge, optimize, dot, recursive

    args = parse_args()

    if (args.res is not None and args.scale is not None) or \
            (args.res is None and args.scale is None):
        print('specify either resolution or scale')
        return

    if args.scale is not None:
        if (args.scale <= 0):
            print('scale should be > 0%')
            return
        if args.scale > 100 and args.nolarge:
            print('option --nolarge used, cannot scale > 100%')
            return
        scale = args.scale
    else:
        HRES, VRES = getres(args.res[0])
        if HRES == 0 or VRES == 0:
            print('resolution must be numeric and > 0')
            return

    brute = args.brute
    overwrite = args.overwrite
    nolarge = args.nolarge
    optimize = args.optimize
    dot = args.dot
    recursive = args.recursive

    if len(args.keywords) == 0:
        print('no source specified')
        return

    for path in args.keywords:
        if not os.path.exists(path):
            print('%s does not exist' % path)
        elif os.path.isdir(path):
            traverse_dir(path)
        else:
            resize_image(path)

if __name__ == '__main__':
    main()
